;;; This file was generated by writeminikanren.pl
;;; Generated at 2006-01-29 15:28:03

;;; Chapter 9 functions:

#| Substitution-access operations |# 
(define-syntax rhs
  (syntax-rules ()
    ((_ x) (cdr x))))

(define-syntax lhs
  (syntax-rules ()
    ((_ x) (car x))))

#| For creating reification-index variables |#
(define-syntax size-s
  (syntax-rules ()
    ((_ x) (length x))))

#| Variable representation. Standard |#
(define-syntax var
  (syntax-rules ()
    ((_ x) (vector x))))

(define-syntax var?
  (syntax-rules ()
    ((_ x) (vector? x))))

(define empty-s '())

(define walk
  (lambda (v s)
    (cond
      ((var? v)
       (let ((a (assq v s)))
         (cond
           (a (walk (rhs a) s))
           (else v))))
      (else v))))

(define ext-s
  (lambda (x v s)
    (cons `(,x . ,v) s)))

(define unify-unchecked
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s v w s))
        ((var? w) (ext-s w v s))
        ((and (pair? v) (pair? w))
         (let ((s (unify-unchecked (car v) (car w) s)))
           (and s (unify-unchecked (cdr v) (cdr w) s))))
        ((equal? v w) s)
        (else #f)))))

(define ext-s-check
  (lambda (x v s)
    (cond
      ((occurs-check x v s) #f)
      (else (ext-s x v s)))))

(define occurs-check
  (lambda (x v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) (eq? v x))
        ((pair? v)
         (or
           (occurs-check x (car v) s)
           (occurs-check x (cdr v) s)))
        (else #f)))))

(define unify
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s-check v w s))
        ((var? w) (ext-s-check w v s))
        ((and (pair? v) (pair? w))
         (let ((s (unify (car v) (car w) s)))
           (and s (unify (cdr v) (cdr w) s))))
        ((equal? v w) s)
        (else #f)))))

(define walk*
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify-s
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v)
         (ext-s v (reify-name (size-s s)) s))
        ((pair? v) (reify-s (cdr v)
                     (reify-s (car v) s)))
        (else s)))))

(define reify-name
  (lambda (n)
    (string->symbol
      (string-append "_" "." (number->string n)))))

(define walk*
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify
  (lambda (v s)
    (let ((v (walk* v s)))
      (walk* v (reify-s v empty-s)))))

;; Beginning of control infrastructure.

;; IIRC, they use macros to better structure some of this code. It
;; doesn't /need/ macros in places (that is, they aren't used to delay
;; computation or significantly shorthand long expressions). But they
;; do let you tell the difference between various kinds of lambda. 

#| 

lambdag@, used to connote a goal
Takes a substitution and returns an s^inf 

|#

(define-syntax lambdag@
  (syntax-rules ()
    ((_ (s) e) (lambda (s) e))))

#| 

lambdaf@, IIRC, was supposed to be the failure continuation. In an
sk/fk-ish model of them. But this also had some delay operator, IIRC.

|# 

(define-syntax lambdaf@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

#|

I only was sure of this because of a note in the file that said this
is sort of a delay.

|#
(define-syntax lambdai@
  (syntax-rules ()
    ((_ () e) (lambdaf@ () e))))

#| 

What does this name mean? 

Perhaps this is the "just one answer" case?

In earlier (and Byrd/Ballantyne) miniKanren implementations they had
cased on {0, exactly1, 1w/possibly-more, incomplete}

|# 
(define-syntax lambdae@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

#| Standard |# 
(define-syntax mzero
  (syntax-rules ()
    ((_) #f)))

(define-syntax unit
  (syntax-rules ()
    ((_ a) a)))

#| 

Their version, from Haskell derivation, begetting "Backtracking,
interleaving ...", expects choice between an answer and a
delay. Always. Ours should be different here, and perhaps less
expensive in some metrics. It should do less under others. 

|# 

(define-syntax choice
  (syntax-rules ()
    ((_ a f) (cons a f))))

#| 

This is the case operator I was mentioning before. 

In this operator, they distinguish between delays of incomplete and
delays of choice, alternative (failure continuation). That's an
interesting observation, and probably important, and something that
you can't readily see in the Racket code.

|# 

(define-syntax case-inf
  (syntax-rules ()
    ((_ e on-zero
          ;; Look at these three as lambda expressions. 
	  ;; Each is a list of bindings, followed by a body expression.
	  ;; The name of the variable in the body describes its usage. 
	  ((a^) on-one)
	  ((a f) on-choice)
	  ((i) on-incomplete))
     (let ((r e)) ;; The let bind avoids evaluating multiple times. 
       (cond
         ((not r)
	  on-zero) ;; no answers. Invoke(?) fk. But this just returns it.
	           ;; so the on-zero must be an un-delayed expression
	           ;; ... representing an fk? Defunctionalized? 
         ((procedure? r)

	  (let ((i r))
	    on-incomplete))

         ((and (pair? r)
	       (procedure? (cdr r))) ;; An answer, plus possibily more
          (let ((a (car r))
		(f (cdr r)))
            on-choice))
         (else ;; This is the exactly-one-answer operation
               ;; They find this important b/c, like, in Mercury, 
	       ;; or something, one answer means it's deterministic.
               ;; You can get way better performance in the special case 
               ;; where there's just one option--no need to search or backtrack.
	   (let 
             ((a^ r)) on-one)))))))

#| 

These run interfaces aren't the interesting bit here. 
No need to worry about them. 
take is where it gets interesting.

|# 

(define-syntax run
  (syntax-rules ()
    ((_ n (x) g^ g ...) (take n (go (x) g^ g ...)))))

(define-syntax run*
  (syntax-rules ()
    ((_ (x) g ...) (run #f (x) g ...))))

#| Take always eats a thunked object, a delayed thing |# 

(define take
  (lambda (n e)
    (cond
      ((and n (zero? n)) '())
      (else
        (let ((p (e)))
          (if p
            (cons (car p)
              (take (and n (- n 1)) (cdr p)))
            '()))))))




(define-syntax go  
  (syntax-rules ()
    ((_ (x) g^ g ...)
     (let ((x (var 'x)))
       (map-inf (lambda (s) (reify x s))
         (lambdaf@ () ((all g^ g ...) empty-s)))))))



(define map-inf
  (lambda (p f)
    (lambdae@ ()
      (case-inf (f)
        #f
        ((s) (cons (p s) (lambdae@ () #f)))
        ((s f) (cons (p s) (map-inf p f)))
        ((i) ((map-inf p i)))))))

(define succeed (lambdag@ (s) (unit s)))

(define fail (lambdag@ (s) (mzero)))

(define-syntax fresh
  (syntax-rules ()
    ((_ (x ...) g^ g ...)
     (lambdag@ (s)
       (let ((x (var 'x)) ...)
         ((all g^ g ...) s))))))

(define-syntax all
  (syntax-rules ()
    ((_) succeed)
    ((_ g) g)
    ((_ g^ g g* ...)
     (all (let ((g0 g^)) (lambdag@ (s) (bind (g0 s) g))) g* ...))))

(define-syntax allw
  (syntax-rules ()
    ((_) succeed)
    ((_ g) g)
    ((_ g^ g g* ...)
     (allw (lambdag@ (s)
             (let ((g1 g^) (g2 g))
               (amb
                 (lambdai@ () ((all g1 g2) s))
                 (lambdai@ () ((all g2 g1) s)))))
       g* ...))))

(define amb
  (lambda (i j)
    (case-inf i
      (mzero)
      ((s) (unit s))
      ((s f) (choice s f))
      ((i) (case-inf j
             (mzero)
             ((s) (unit s))
             ((s f) (choice s f))
             ((j) (lambdai@ () (amb (i) (j)))))))))

(define ==
  (lambda (v w)
    (lambdag@ (s)
      (unify v w s))))

(define ==-unchecked
  (lambda (v w)
    (lambdag@ (s)
      (unify-unchecked v w s))))

(define-syntax conde
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g0 g ...)) (all g0 g ...))
    ((_ (g0 g ...) c ...)
     (lambdag@ (s)
       (mplus
         (lambdai@ () ((all g0 g ...) s))
         (lambdaf@ () ((conde c ...) s)))))))

(define bind
  (lambda (s-inf g)
    (case-inf s-inf
      (mzero)
      ((s) (g s))
      ((s f) (mplus (g s) (lambdaf@ () (bind (f) g))))
      ((i) (lambdai@ () (bind (i) g))))))

;; JBH: I did not write the below comment. Interesting. I wonder what
;; this is a simplification /of/?  Could we "unwind" the improvement
;; back to the type-correct simpler version?

;;; This seems a lot simpler, but may have type problems
(define mplus
  (lambda (s-inf f)
    (let loop ((s-inf s-inf) (f f) (b #t))
      (case-inf s-inf
        f
        ((s) (choice s f))
        ((s f^) (choice s (lambdaf@ () (loop (f) f^ #t))))
        ((i) (lambdai@ () (if b (loop (i) f #f) (loop (f) i #t))))))))


;; I think we can ignore these, safely. They're impure control
;; operators. So at the very least they aren't showstoppers for v 1.0

#|

(define-syntax project
  (syntax-rules ()
    ((_ (x ...) g^ g ...)
     (lambdag@ (s)
       (let ((x (walk* x s)) ...)
         ((all g^ g ...) s))))))

(define-syntax conda
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g ...)) (all g ...))
    ((_ (g0 g ...) c ...) (ifa g0 (all g ...) (conda c ...)))))

(define-syntax condu
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g ...)) (all g ...))
    ((_ (g0 g ...) c ...) (ifu g0 (all g ...) (condu c ...)))))

(define-syntax ifa
  (syntax-rules ()
    ((_ g0 g1 g2)
     (lambdag@ (s)
       (let loop ((s-inf (g0 s)))
         (case-inf s-inf
           (g2 s)
           ((s) (g1 s))
           ((s f) (bind s-inf g1))
           ((i) (lambdai@ () (loop (i))))))))))

(define-syntax ifu
  (syntax-rules ()
    ((_ g0 g1 g2)
     (lambdag@ (s)
       (let loop ((s-inf (g0 s)))
         (case-inf s-inf
           (g2 s)
           ((s) (g1 s))
           ((s f) (g1 s))
           ((i) (lambdai@ () (loop (i))))))))))

;;; For backward compatibility.
; Just the lambda...
(define-syntax lambda-limited
  (syntax-rules ()
    ((_ n formals g) (lambda formals g))))

(define-syntax alli
  (syntax-rules ()
    ((_ args ...) (all args ...))))

(define-syntax condi
  (syntax-rules ()
    ((_ args ...) (conde args ...))))

(define-syntax condw
  (syntax-rules ()
    ((_ args ...) (conde args ...))))

|# 
